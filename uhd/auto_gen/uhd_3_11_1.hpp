/** This file is automatically generated. Do not edit. **/

#include <uhd/version.hpp>

#if (UHD_VERSION / 100) == 31101

#ifndef __UHD_GEN_HPP__
#define __UHD_GEN_HPP__

#include <Python.h>

#include <uhd/usrp/multi_usrp.hpp>
#include <uhd/exception.hpp>

#include "uhd.hpp"
#include "uhd_usrp.hpp"
#include "uhd_types.hpp"

namespace uhd {

#define DOC_CLEAR_COMMAND_TIME \
"Clear the command time so future commands are sent ASAP.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): which motherboard to set the config\n"
PyObject *Usrp_clear_command_time(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            self->dev->clear_command_time(mboard.get());
        } else {
            self->dev->clear_command_time();
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_ENUMERATE_REGISTERS \
"Enumerate the full paths of all low-level USRP registers accessible to read/write\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of register paths\n"
PyObject *Usrp_enumerate_registers(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->enumerate_registers(mboard.get()));
        } else {
            return from(self->dev->enumerate_registers());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_CLOCK_SOURCE \
"Get the currently set clock source.\n" \
"\n" \
"Args:\n" \
"    mboard (int): which motherboard to get the config\n" \
"\n" \
"Returns:\n" \
"    str: the string representing the clock source\n"
PyObject *Usrp_get_clock_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1.", nargs);

    Expect<size_t> mboard;
    if (!(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_clock_source(mboard.get()));
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_CLOCK_SOURCES \
"Get a list of possible clock sources.\n" \
"\n" \
"Args:\n" \
"    mboard (int): which motherboard to get the list\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible settings\n"
PyObject *Usrp_get_clock_sources(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1.", nargs);

    Expect<size_t> mboard;
    if (!(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_clock_sources(mboard.get()));
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_FE_RX_FREQ_RANGE \
"Get the center frequency range of the RF frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a frequency range object\n"
PyObject *Usrp_get_fe_rx_freq_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_fe_rx_freq_range(chan.get()));
        } else {
            return from(self->dev->get_fe_rx_freq_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_FE_TX_FREQ_RANGE \
"Get the center frequency range of the TX frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a frequency range object\n"
PyObject *Usrp_get_fe_tx_freq_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_fe_tx_freq_range(chan.get()));
        } else {
            return from(self->dev->get_fe_tx_freq_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_FILTER_NAMES \
"Enumerate the available filters in the signal path.\n" \
"\n" \
"Args:\n" \
"    search_mask (str, optional):\n" \
"        Select only certain filter names by specifying this search mask.\n" \
"        E.g. if search mask is set to \"rx_frontends/A\" only filter names including that string will be returned.\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings representing the selected filter names.\n"
PyObject *Usrp_get_filter_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<std::string> search_mask;
    if (nargs > 0 && !(search_mask = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "search_mask: %s", search_mask.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_filter_names(search_mask.get()));
        } else {
            return from(self->dev->get_filter_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_GPIO_ATTR \
"Get a GPIO attribute on a particular GPIO bank.\n" \
"Possible attribute names:\n" \
" - CTRL - 1 for ATR mode 0 for GPIO mode\n" \
" - DDR - 1 for output 0 for input\n" \
" - OUT - GPIO output level (not ATR mode)\n" \
" - ATR_0X - ATR idle state\n" \
" - ATR_RX - ATR receive only state\n" \
" - ATR_TX - ATR transmit only state\n" \
" - ATR_XX - ATR full duplex state\n" \
" - READBACK - readback input GPIOs\n" \
"\n" \
"Args:\n" \
"    bank (str): the name of a GPIO bank\n" \
"    attr (str): the name of a GPIO attribute\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    int: the value set for this attribute\n"
PyObject *Usrp_get_gpio_attr(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<std::string> bank;
    if (!(bank = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "bank: %s", bank.what());
    Expect<std::string> attr;
    if (!(attr = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "attr: %s", attr.what());

    Expect<size_t> mboard;
    if (nargs > 2 && !(mboard = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            return from(self->dev->get_gpio_attr(bank.get(), attr.get(), mboard.get()));
        } else {
            return from(self->dev->get_gpio_attr(bank.get(), attr.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_GPIO_BANKS \
"Enumerate gpio banks on the specified device.\n" \
"\n" \
"Args:\n" \
"    mboard (int): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    list: a list of string for each bank name\n"
PyObject *Usrp_get_gpio_banks(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1.", nargs);

    Expect<size_t> mboard;
    if (!(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_gpio_banks(mboard.get()));
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_GPIO_STRING_ATTR \
"Get a GPIO attribute on a particular GPIO bank.\n" \
"Possible attribute names:\n" \
" - SRC  - \"PS\" for handling by processing system\n" \
"        - \"RADIO_N/M\" for handling by radio block with N is in [0..Number of Radio]; M is in [0..Number of port per Radio]\n" \
" - CTRL - \"ATR\"  for ATR mode\n" \
"        - \"GPIO\" for GPIO mode\n" \
" - DDR  - \"OUT\" for output\n" \
"        - \"IN\"  for input\n" \
" - OUT -  a string of numbers representing GPIO output level (not ATR mode)\n" \
"       - \"HIGH\"or \"LOW\" as GPIO output level that apply for each bit mask that is 1\n" \
" - ATR_0X - a string of numbers representing a value of the ATR idle state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR idle state register\n" \
" - ATR_RX - a string of numbers representing a value of a ATR receive only state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR receive only state register\n" \
" - ATR_TX - a string of numbers representing a value of the ATR transmit only state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR transmit only state register\n" \
" - ATR_XX - a string of numbers representing a value of the ATR full duplex state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR full duplex state register\n" \
" - READBACK - readback input GPIOs\n" \
"\n" \
"Args:\n" \
"    bank (str): the name of a GPIO bank\n" \
"    attr (str): the name of a GPIO attribute\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    list: the value set for this attribute in vector of strings\n"
PyObject *Usrp_get_gpio_string_attr(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<std::string> bank;
    if (!(bank = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "bank: %s", bank.what());
    Expect<std::string> attr;
    if (!(attr = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "attr: %s", attr.what());

    Expect<size_t> mboard;
    if (nargs > 2 && !(mboard = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            return from(self->dev->get_gpio_string_attr(bank.get(), attr.get(), mboard.get()));
        } else {
            return from(self->dev->get_gpio_string_attr(bank.get(), attr.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_MASTER_CLOCK_RATE \
"Get the master clock rate.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    float: the master clock rate in Hz.\n"
PyObject *Usrp_get_master_clock_rate(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_master_clock_rate(mboard.get()));
        } else {
            return from(self->dev->get_master_clock_rate());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_MBOARD_NAME \
"Get canonical name for this USRP motherboard.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): which motherboard to query\n" \
"\n" \
"Returns:\n" \
"    str: a string representing the name\n"
PyObject *Usrp_get_mboard_name(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_mboard_name(mboard.get()));
        } else {
            return from(self->dev->get_mboard_name());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_MBOARD_SENSOR \
"Get a motherboard sensor value.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the sensor\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    dict: a sensor value object\n"
PyObject *Usrp_get_mboard_sensor(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_mboard_sensor(name.get(), mboard.get()));
        } else {
            return from(self->dev->get_mboard_sensor(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_MBOARD_SENSOR_NAMES \
"Get a list of possible motherboard sensor names.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of sensor names\n"
PyObject *Usrp_get_mboard_sensor_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_mboard_sensor_names(mboard.get()));
        } else {
            return from(self->dev->get_mboard_sensor_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_NORMALIZED_RX_GAIN \
"Return the normalized RX gain value.\n" \
"See set_normalized_rx_gain() for a discussion of normalized\n" \
"gains.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: s The normalized gain (in [0, 1])\n"
PyObject *Usrp_get_normalized_rx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_normalized_rx_gain(chan.get()));
        } else {
            return from(self->dev->get_normalized_rx_gain());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_NORMALIZED_TX_GAIN \
"Return the normalized TX gain value.\n" \
"See set_normalized_rx_gain() for a discussion of normalized\n" \
"gains.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: s The normalized gain (in [0, 1])\n"
PyObject *Usrp_get_normalized_tx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_normalized_tx_gain(chan.get()));
        } else {
            return from(self->dev->get_normalized_tx_gain());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_NUM_MBOARDS \
"Get the number of USRP motherboards in this configuration.\n" \
"\n" \
"Returns:\n" \
"    int: value\n"
PyObject *Usrp_get_num_mboards(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 0)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected None.", nargs);

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_num_mboards());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_PP_STRING \
"Get a printable summary for this USRP configuration.\n" \
"\n" \
"Returns:\n" \
"    str: a printable string\n"
PyObject *Usrp_get_pp_string(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 0)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected None.", nargs);

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_pp_string());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_ANTENNA \
"Get the selected RX antenna on the frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: the antenna name\n"
PyObject *Usrp_get_rx_antenna(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_antenna(chan.get()));
        } else {
            return from(self->dev->get_rx_antenna());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_ANTENNAS \
"Get a list of possible RX antennas on the frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of antenna names\n"
PyObject *Usrp_get_rx_antennas(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_antennas(chan.get()));
        } else {
            return from(self->dev->get_rx_antennas());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_BANDWIDTH \
"Get the RX bandwidth on the frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the bandwidth in Hz\n"
PyObject *Usrp_get_rx_bandwidth(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_bandwidth(chan.get()));
        } else {
            return from(self->dev->get_rx_bandwidth());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_BANDWIDTH_RANGE \
"Get the range of the possible RX bandwidth settings.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a range of bandwidths in Hz\n"
PyObject *Usrp_get_rx_bandwidth_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_bandwidth_range(chan.get()));
        } else {
            return from(self->dev->get_rx_bandwidth_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_FREQ \
"Get the RX center frequency.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the frequency in Hz\n"
PyObject *Usrp_get_rx_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_freq(chan.get()));
        } else {
            return from(self->dev->get_rx_freq());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_FREQ_RANGE \
"Get the RX center frequency range.\n" \
"This range includes the overall tunable range of the RX chain,\n" \
"including frontend chain and digital down conversion chain.\n" \
"This tunable limit does not include the baseband bandwidth;\n" \
"users should assume that the actual range is +/- samp_rate/2.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a frequency range object\n"
PyObject *Usrp_get_rx_freq_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_freq_range(chan.get()));
        } else {
            return from(self->dev->get_rx_freq_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_GAIN \
"(1) ""Get the RX gain value for the specified gain element.\n" \
"For an empty name, sum across all gain elements.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the gain element\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the gain in dB\n" \
"\n" \
"(2) ""A convenience wrapper for getting overall RX gain\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): chan\n" \
"\n" \
"Returns:\n" \
"    float: value\n"
static PyObject *Usrp_get_rx_gain_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_gain(name.get(), chan.get()));
        } else {
            return from(self->dev->get_rx_gain(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

static PyObject *Usrp_get_rx_gain_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_gain(chan.get()));
        } else {
            return from(self->dev->get_rx_gain());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

PyObject *Usrp_get_rx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 1 && nargs <= 2
        && is<std::string>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_get_rx_gain_0(self, args);
    } else if (nargs >= 0 && nargs <= 1
        && (nargs <= 0 || is<size_t>(PyTuple_GetItem(args, 0)))) {
        return Usrp_get_rx_gain_1(self, args);
    }
    return Usrp_get_rx_gain_0(self, args);
}

#define DOC_GET_RX_GAIN_NAMES \
"Get the names of the gain elements in the RX chain.\n" \
"Gain elements are ordered from antenna to FPGA.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of gain element names\n"
PyObject *Usrp_get_rx_gain_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_gain_names(chan.get()));
        } else {
            return from(self->dev->get_rx_gain_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_GAIN_PROFILE \
"Get the RX gain profile.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: a string of current RX gain profile of corresponding channel.\n"
PyObject *Usrp_get_rx_gain_profile(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_gain_profile(chan.get()));
        } else {
            return from(self->dev->get_rx_gain_profile());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_GAIN_PROFILE_NAMES \
"Get a list of possible RX gain profile options\n" \
"Example: On the TwinRX, this will return \"low-noise\", \"low-distortion\" or \"default\".\n" \
"These names can be used in gain-profile related API called.\n" \
"An empty return value doesn't mean there are no profile options, it means that\n" \
"this radio does not have any gain profiles implemented, and typically means\n" \
"there is only one default profile of set gain\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible gain profile options, or an empty list of\n" \
"          this doesn't apply.\n"
PyObject *Usrp_get_rx_gain_profile_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_gain_profile_names(chan.get()));
        } else {
            return from(self->dev->get_rx_gain_profile_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_GAIN_RANGE \
"(1) ""Get the RX gain range for the specified gain element.\n" \
"For an empty name, calculate the overall gain range.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the gain element\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a gain range object\n" \
"\n" \
"(2) ""A convenience wrapper for getting overall RX gain range\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): chan\n" \
"\n" \
"Returns:\n" \
"    dict: value\n"
static PyObject *Usrp_get_rx_gain_range_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_gain_range(name.get(), chan.get()));
        } else {
            return from(self->dev->get_rx_gain_range(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

static PyObject *Usrp_get_rx_gain_range_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_gain_range(chan.get()));
        } else {
            return from(self->dev->get_rx_gain_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

PyObject *Usrp_get_rx_gain_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 1 && nargs <= 2
        && is<std::string>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_get_rx_gain_range_0(self, args);
    } else if (nargs >= 0 && nargs <= 1
        && (nargs <= 0 || is<size_t>(PyTuple_GetItem(args, 0)))) {
        return Usrp_get_rx_gain_range_1(self, args);
    }
    return Usrp_get_rx_gain_range_0(self, args);
}

#define DOC_GET_RX_LO_EXPORT_ENABLED \
"Returns true if the currently selected LO is being exported.\n" \
"\n" \
"Args:\n" \
"    name (str, optional): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    bool: value\n"
PyObject *Usrp_get_rx_lo_export_enabled(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 2.", nargs);

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 0 && !(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_lo_export_enabled(name.get(), chan.get()));
        } else if (nargs == 1) {
            return from(self->dev->get_rx_lo_export_enabled(name.get()));
        } else {
            return from(self->dev->get_rx_lo_export_enabled());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_LO_FREQ \
"Get the current RX LO frequency (Advanced).\n" \
"If the channel does not have independently configurable LOs\n" \
"the current rf frequency will be returned. See also set_rx_lo_freq() for\n" \
"more information.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the configured LO frequency\n"
PyObject *Usrp_get_rx_lo_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_lo_freq(name.get(), chan.get()));
        } else {
            return from(self->dev->get_rx_lo_freq(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_LO_FREQ_RANGE \
"Get the LO frequency range of the RX LO.\n" \
"If the channel does not have independently configurable LOs\n" \
"the rf frequency range will be returned.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a frequency range object\n"
PyObject *Usrp_get_rx_lo_freq_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_lo_freq_range(name.get(), chan.get()));
        } else {
            return from(self->dev->get_rx_lo_freq_range(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_LO_NAMES \
"Get a list of possible LO stage names\n" \
"Example: On the TwinRX, this will return \"LO1\", \"LO2\". These names can\n" \
"are used in other LO-related API calls, so this function can be used for\n" \
"automatically enumerating LO stages.\n" \
"An empty return value doesn't mean there are no LOs, it means that this\n" \
"radio does not have an LO API implemented, and typically means the LOs\n" \
"have no direct way of being controlled other than setting the frequency.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible LO names, or an empty list of\n" \
"          this doesn't apply (i.e. there are no controllable LO stages)\n"
PyObject *Usrp_get_rx_lo_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_lo_names(chan.get()));
        } else {
            return from(self->dev->get_rx_lo_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_LO_SOURCE \
"Get the currently selected LO source.\n" \
"Channels without controllable LO sources will always return \"internal\".\n" \
"\n" \
"Args:\n" \
"    name (str, optional): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: the configured LO source\n"
PyObject *Usrp_get_rx_lo_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 2.", nargs);

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 0 && !(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_lo_source(name.get(), chan.get()));
        } else if (nargs == 1) {
            return from(self->dev->get_rx_lo_source(name.get()));
        } else {
            return from(self->dev->get_rx_lo_source());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_LO_SOURCES \
"Get a list of possible LO sources.\n" \
"Channels which do not have controllable LO sources will return\n" \
"\"internal\". Typical values are \"internal\" and \"external\", although the\n" \
"TwinRX has more options, such as \"companion\". These options are device-\n" \
"specific.\n" \
"\n" \
"Args:\n" \
"    name (str, optional): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible settings\n"
PyObject *Usrp_get_rx_lo_sources(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 2.", nargs);

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 0 && !(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_lo_sources(name.get(), chan.get()));
        } else if (nargs == 1) {
            return from(self->dev->get_rx_lo_sources(name.get()));
        } else {
            return from(self->dev->get_rx_lo_sources());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_NUM_CHANNELS \
"Get the number of RX channels in this configuration.\n" \
"This is the number of USRPs times the number of RX channels per board,\n" \
"where the number of RX channels per board is homogeneous among all USRPs.\n" \
"\n" \
"Returns:\n" \
"    int: value\n"
PyObject *Usrp_get_rx_num_channels(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 0)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected None.", nargs);

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_rx_num_channels());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_RATE \
"Gets the RX sample rate.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the rate in Sps\n"
PyObject *Usrp_get_rx_rate(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_rate(chan.get()));
        } else {
            return from(self->dev->get_rx_rate());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_RATES \
"Get a range of possible RX rates.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: the meta range of rates\n"
PyObject *Usrp_get_rx_rates(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_rates(chan.get()));
        } else {
            return from(self->dev->get_rx_rates());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_SENSOR \
"Get an RX frontend sensor value.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the sensor\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a sensor value object\n"
PyObject *Usrp_get_rx_sensor(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_rx_sensor(name.get(), chan.get()));
        } else {
            return from(self->dev->get_rx_sensor(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_SENSOR_NAMES \
"Get a list of possible RX frontend sensor names.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of sensor names\n"
PyObject *Usrp_get_rx_sensor_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_sensor_names(chan.get()));
        } else {
            return from(self->dev->get_rx_sensor_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_SUBDEV_NAME \
"Get the name of the RX frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: the frontend name\n"
PyObject *Usrp_get_rx_subdev_name(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_subdev_name(chan.get()));
        } else {
            return from(self->dev->get_rx_subdev_name());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_RX_SUBDEV_SPEC \
"Get the RX frontend specification.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    str: the frontend specification in use\n"
PyObject *Usrp_get_rx_subdev_spec(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_rx_subdev_spec(mboard.get()));
        } else {
            return from(self->dev->get_rx_subdev_spec());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TIME_LAST_PPS \
"Get the time when the last pps pulse occurred.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): which motherboard to query\n" \
"\n" \
"Returns:\n" \
"    TimeSpec: a timespec representing the last pps\n"
PyObject *Usrp_get_time_last_pps(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_time_last_pps(mboard.get()));
        } else {
            return from(self->dev->get_time_last_pps());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TIME_NOW \
"Get the current time in the usrp time registers.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): which motherboard to query\n" \
"\n" \
"Returns:\n" \
"    TimeSpec: a timespec representing current usrp time\n"
PyObject *Usrp_get_time_now(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_time_now(mboard.get()));
        } else {
            return from(self->dev->get_time_now());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TIME_SOURCE \
"Get the currently set time source.\n" \
"\n" \
"Args:\n" \
"    mboard (int): which motherboard to get the config\n" \
"\n" \
"Returns:\n" \
"    str: the string representing the time source\n"
PyObject *Usrp_get_time_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1.", nargs);

    Expect<size_t> mboard;
    if (!(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_time_source(mboard.get()));
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TIME_SOURCES \
"Get a list of possible time sources.\n" \
"\n" \
"Args:\n" \
"    mboard (int): which motherboard to get the list\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible settings\n"
PyObject *Usrp_get_time_sources(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1.", nargs);

    Expect<size_t> mboard;
    if (!(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_time_sources(mboard.get()));
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TIME_SYNCHRONIZED \
"Are the times across all motherboards in this configuration synchronized?\n" \
"Checks that all time registers are approximately close but not exact,\n" \
"given that the RTT may varying for a control packet transaction.\n" \
"\n" \
"Returns:\n" \
"    bool: true when all motherboards time registers are in sync\n"
PyObject *Usrp_get_time_synchronized(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 0)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected None.", nargs);

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_time_synchronized());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_ANTENNA \
"Get the selected TX antenna on the frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: the antenna name\n"
PyObject *Usrp_get_tx_antenna(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_antenna(chan.get()));
        } else {
            return from(self->dev->get_tx_antenna());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_ANTENNAS \
"Get a list of possible TX antennas on the frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of antenna names\n"
PyObject *Usrp_get_tx_antennas(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_antennas(chan.get()));
        } else {
            return from(self->dev->get_tx_antennas());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_BANDWIDTH \
"Get the TX bandwidth on the frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the bandwidth in Hz\n"
PyObject *Usrp_get_tx_bandwidth(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_bandwidth(chan.get()));
        } else {
            return from(self->dev->get_tx_bandwidth());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_BANDWIDTH_RANGE \
"Get the range of the possible TX bandwidth settings.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a range of bandwidths in Hz\n"
PyObject *Usrp_get_tx_bandwidth_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_bandwidth_range(chan.get()));
        } else {
            return from(self->dev->get_tx_bandwidth_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_FREQ \
"Get the TX center frequency.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the frequency in Hz\n"
PyObject *Usrp_get_tx_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_freq(chan.get()));
        } else {
            return from(self->dev->get_tx_freq());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_FREQ_RANGE \
"Get the TX center frequency range.\n" \
"This range includes the overall tunable range of the TX chain,\n" \
"including frontend chain and digital up conversion chain.\n" \
"This tunable limit does not include the baseband bandwidth;\n" \
"users should assume that the actual range is +/- samp_rate/2.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a frequency range object\n"
PyObject *Usrp_get_tx_freq_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_freq_range(chan.get()));
        } else {
            return from(self->dev->get_tx_freq_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_GAIN \
"(1) ""Get the TX gain value for the specified gain element.\n" \
"For an empty name, sum across all gain elements.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the gain element\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the gain in dB\n" \
"\n" \
"(2) ""A convenience wrapper for getting overall TX gain\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): chan\n" \
"\n" \
"Returns:\n" \
"    float: value\n"
static PyObject *Usrp_get_tx_gain_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_gain(name.get(), chan.get()));
        } else {
            return from(self->dev->get_tx_gain(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

static PyObject *Usrp_get_tx_gain_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_gain(chan.get()));
        } else {
            return from(self->dev->get_tx_gain());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

PyObject *Usrp_get_tx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 1 && nargs <= 2
        && is<std::string>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_get_tx_gain_0(self, args);
    } else if (nargs >= 0 && nargs <= 1
        && (nargs <= 0 || is<size_t>(PyTuple_GetItem(args, 0)))) {
        return Usrp_get_tx_gain_1(self, args);
    }
    return Usrp_get_tx_gain_0(self, args);
}

#define DOC_GET_TX_GAIN_NAMES \
"Get the names of the gain elements in the TX chain.\n" \
"Gain elements are ordered from antenna to FPGA.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of gain element names\n"
PyObject *Usrp_get_tx_gain_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_gain_names(chan.get()));
        } else {
            return from(self->dev->get_tx_gain_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_GAIN_PROFILE \
"Get the TX gain profile.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: a string of current TX gain profile of corresponding channel.\n"
PyObject *Usrp_get_tx_gain_profile(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_gain_profile(chan.get()));
        } else {
            return from(self->dev->get_tx_gain_profile());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_GAIN_PROFILE_NAMES \
"Get a list of possible TX gain profile options\n" \
"Example: On the N310, this will return \"manual\" or \"default\".\n" \
"These names can be used in gain related API called.\n" \
"An empty return value doesn't mean there are no profile options, it means that\n" \
"this radio does not have any gain profiles implemented, and typically means\n" \
"there is only one default profile of set gain\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible gain profile options, or an empty list of\n" \
"          this doesn't apply.\n"
PyObject *Usrp_get_tx_gain_profile_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_gain_profile_names(chan.get()));
        } else {
            return from(self->dev->get_tx_gain_profile_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_GAIN_RANGE \
"(1) ""Get the TX gain range for the specified gain element.\n" \
"For an empty name, calculate the overall gain range.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the gain element\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a gain range object\n" \
"\n" \
"(2) ""A convenience wrapper for getting overall TX gain range\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): chan\n" \
"\n" \
"Returns:\n" \
"    dict: value\n"
static PyObject *Usrp_get_tx_gain_range_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_gain_range(name.get(), chan.get()));
        } else {
            return from(self->dev->get_tx_gain_range(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

static PyObject *Usrp_get_tx_gain_range_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_gain_range(chan.get()));
        } else {
            return from(self->dev->get_tx_gain_range());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

PyObject *Usrp_get_tx_gain_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 1 && nargs <= 2
        && is<std::string>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_get_tx_gain_range_0(self, args);
    } else if (nargs >= 0 && nargs <= 1
        && (nargs <= 0 || is<size_t>(PyTuple_GetItem(args, 0)))) {
        return Usrp_get_tx_gain_range_1(self, args);
    }
    return Usrp_get_tx_gain_range_0(self, args);
}

#define DOC_GET_TX_LO_EXPORT_ENABLED \
"Returns true if the currently selected LO is being exported.\n" \
"\n" \
"Args:\n" \
"    name (str, optional): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    bool: value\n"
PyObject *Usrp_get_tx_lo_export_enabled(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 2.", nargs);

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 0 && !(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_lo_export_enabled(name.get(), chan.get()));
        } else if (nargs == 1) {
            return from(self->dev->get_tx_lo_export_enabled(name.get()));
        } else {
            return from(self->dev->get_tx_lo_export_enabled());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_LO_FREQ \
"Get the current TX LO frequency (Advanced).\n" \
"If the channel does not have independently configurable LOs\n" \
"the current rf frequency will be returned. See also set_tx_lo_freq() for\n" \
"more information.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the configured LO frequency\n"
PyObject *Usrp_get_tx_lo_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_lo_freq(name.get(), chan.get()));
        } else {
            return from(self->dev->get_tx_lo_freq(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_LO_FREQ_RANGE \
"Get the LO frequency range of the TX LO.\n" \
"If the channel does not have independently configurable LOs\n" \
"the rf frequency range will be returned.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a frequency range object\n"
PyObject *Usrp_get_tx_lo_freq_range(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_lo_freq_range(name.get(), chan.get()));
        } else {
            return from(self->dev->get_tx_lo_freq_range(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_LO_NAMES \
"Get a list of possible TX LO stage names\n" \
"See also get_rx_lo_names().\n" \
"An empty return value doesn't mean there are no LOs, it means that this\n" \
"radio does not have an LO API implemented, and typically means the LOs\n" \
"have no direct way of being controlled other than setting the frequency.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible LO names, or an empty list of\n" \
"          this doesn't apply (i.e. there are no controllable LO stages)\n"
PyObject *Usrp_get_tx_lo_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_lo_names(chan.get()));
        } else {
            return from(self->dev->get_tx_lo_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_LO_SOURCE \
"Get the currently selected TX LO source.\n" \
"Channels without controllable LO sources will always return \"internal\".\n" \
"\n" \
"Args:\n" \
"    name (str, optional): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: the configured LO source\n"
PyObject *Usrp_get_tx_lo_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 2.", nargs);

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 0 && !(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_lo_source(name.get(), chan.get()));
        } else if (nargs == 1) {
            return from(self->dev->get_tx_lo_source(name.get()));
        } else {
            return from(self->dev->get_tx_lo_source());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_LO_SOURCES \
"Get a list of possible LO sources.\n" \
"Channels which do not have controllable LO sources will return\n" \
"\"internal\". Typical values are \"internal\" and \"external\".\n" \
"These options are device-specific.\n" \
"\n" \
"Args:\n" \
"    name (str, optional): the name of the LO stage to query\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of strings for possible settings\n"
PyObject *Usrp_get_tx_lo_sources(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 2.", nargs);

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 0 && !(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_lo_sources(name.get(), chan.get()));
        } else if (nargs == 1) {
            return from(self->dev->get_tx_lo_sources(name.get()));
        } else {
            return from(self->dev->get_tx_lo_sources());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_NUM_CHANNELS \
"Get the number of TX channels in this configuration.\n" \
"This is the number of USRPs times the number of TX channels per board,\n" \
"where the number of TX channels per board is homogeneous among all USRPs.\n" \
"\n" \
"Returns:\n" \
"    int: value\n"
PyObject *Usrp_get_tx_num_channels(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 0)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected None.", nargs);

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        return from(self->dev->get_tx_num_channels());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_RATE \
"Gets the TX sample rate.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: the rate in Sps\n"
PyObject *Usrp_get_tx_rate(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_rate(chan.get()));
        } else {
            return from(self->dev->get_tx_rate());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_RATES \
"Get a range of possible TX rates.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: the meta range of rates\n"
PyObject *Usrp_get_tx_rates(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_rates(chan.get()));
        } else {
            return from(self->dev->get_tx_rates());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_SENSOR \
"Get an TX frontend sensor value.\n" \
"\n" \
"Args:\n" \
"    name (str): the name of the sensor\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a sensor value object\n"
PyObject *Usrp_get_tx_sensor(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->get_tx_sensor(name.get(), chan.get()));
        } else {
            return from(self->dev->get_tx_sensor(name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_SENSOR_NAMES \
"Get a list of possible TX frontend sensor names.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    list: a vector of sensor names\n"
PyObject *Usrp_get_tx_sensor_names(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_sensor_names(chan.get()));
        } else {
            return from(self->dev->get_tx_sensor_names());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_SUBDEV_NAME \
"Get the name of the TX frontend.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    str: the frontend name\n"
PyObject *Usrp_get_tx_subdev_name(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_subdev_name(chan.get()));
        } else {
            return from(self->dev->get_tx_subdev_name());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_TX_SUBDEV_SPEC \
"Get the TX frontend specification.\n" \
"\n" \
"Args:\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    str: the frontend specification in use\n"
PyObject *Usrp_get_tx_subdev_spec(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> mboard;
    if (nargs > 0 && !(mboard = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_tx_subdev_spec(mboard.get()));
        } else {
            return from(self->dev->get_tx_subdev_spec());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_USRP_RX_INFO \
"Returns identifying information about this USRP's configuration.\n" \
"Returns motherboard ID, name, and serial.\n" \
"Returns daughterboard RX ID, subdev name and spec, serial, and antenna.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: RX info\n"
PyObject *Usrp_get_usrp_rx_info(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_usrp_rx_info(chan.get()));
        } else {
            return from(self->dev->get_usrp_rx_info());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_GET_USRP_TX_INFO \
"Returns identifying information about this USRP's configuration.\n" \
"Returns motherboard ID, name, and serial.\n" \
"Returns daughterboard TX ID, subdev name and spec, serial, and antenna.\n" \
"\n" \
"Args:\n" \
"    chan (int, optional): channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: TX info\n"
PyObject *Usrp_get_usrp_tx_info(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 0 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 0 to 1.", nargs);

    Expect<size_t> chan;
    if (nargs > 0 && !(chan = to<size_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 1) {
            return from(self->dev->get_usrp_tx_info(chan.get()));
        } else {
            return from(self->dev->get_usrp_tx_info());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_READ_REGISTER \
"Read a low-level register field from a register in the USRP hardware\n" \
"\n" \
"Args:\n" \
"    path (str): the full path to the register\n" \
"    field (int): the identifier of bitfield to be read\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"Returns:\n" \
"    int: the value of the register field\n"
PyObject *Usrp_read_register(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<std::string> path;
    if (!(path = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "path: %s", path.what());
    Expect<uint32_t> field;
    if (!(field = to<uint32_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "field: %s", field.what());

    Expect<size_t> mboard;
    if (nargs > 2 && !(mboard = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            return from(self->dev->read_register(path.get(), field.get(), mboard.get()));
        } else {
            return from(self->dev->read_register(path.get(), field.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_SET_CLOCK_SOURCE \
"Set the clock source for the usrp device.\n" \
"This sets the source for a 10 MHz reference clock.\n" \
"Typical options for source: internal, external, MIMO.\n" \
"\n" \
"Args:\n" \
"    source (str): a string representing the clock source\n" \
"    mboard (int, optional): which motherboard to set the config\n"
PyObject *Usrp_set_clock_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> source;
    if (!(source = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "source: %s", source.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_clock_source(source.get(), mboard.get());
        } else {
            self->dev->set_clock_source(source.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_CLOCK_SOURCE_OUT \
"Send the clock source to an output connector.\n" \
"This call is only applicable on devices with reference outputs.\n" \
"By default, the reference output will be enabled for ease of use.\n" \
"This call may be used to enable or disable the output.\n" \
"\n" \
"Args:\n" \
"    enb (bool): true to output the clock source.\n" \
"    mboard (int, optional): which motherboard to set\n"
PyObject *Usrp_set_clock_source_out(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<bool> enb;
    if (!(enb = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enb: %s", enb.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_clock_source_out(enb.get(), mboard.get());
        } else {
            self->dev->set_clock_source_out(enb.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_COMMAND_TIME \
"Set the time at which the control commands will take effect.\n" \
"A timed command will back-pressure all subsequent timed commands,\n" \
"assuming that the subsequent commands occur within the time-window.\n" \
"If the time spec is late, the command will be activated upon arrival.\n" \
"\n" \
"Args:\n" \
"    time_spec (float, TimeSpec): the time at which the next command will activate\n" \
"    mboard (int, optional): which motherboard to set the config\n"
PyObject *Usrp_set_command_time(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<time_spec_t> time_spec;
    if (!(time_spec = to<time_spec_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "time_spec: %s", time_spec.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_command_time(time_spec.get(), mboard.get());
        } else {
            self->dev->set_command_time(time_spec.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_GPIO_ATTR \
"(1) ""Set a GPIO attribute on a particular GPIO bank.\n" \
"Possible attribute names:\n" \
" - CTRL - 1 for ATR mode 0 for GPIO mode\n" \
" - DDR - 1 for output 0 for input\n" \
" - OUT - GPIO output level (not ATR mode)\n" \
" - ATR_0X - ATR idle state\n" \
" - ATR_RX - ATR receive only state\n" \
" - ATR_TX - ATR transmit only state\n" \
" - ATR_XX - ATR full duplex state\n" \
"\n" \
"Args:\n" \
"    bank (str): the name of a GPIO bank\n" \
"    attr (str): the name of a GPIO attribute\n" \
"    value (int): the new value for this GPIO bank\n" \
"    mask (int, optional): the bit mask to effect which pins are changed\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n" \
"\n" \
"(2) ""Set a GPIO attribute on a particular GPIO bank.\n" \
"Possible attribute names:\n" \
" - SRC  - \"PS\" for handling by processing system\n" \
"        - \"RADIO_N/M\" for handling by radio block with N is in [0..Number of Radio]; M is in [0..Number of port per Radio]\n" \
" - CTRL - \"ATR\"  for ATR mode\n" \
"        - \"GPIO\" for GPIO mode\n" \
" - DDR  - \"OUT\" for output\n" \
"        - \"IN\"  for input\n" \
" - OUT -  a string of numbers representing GPIO output level (not ATR mode)\n" \
"       - \"HIGH\"or \"LOW\" as GPIO output level that apply for each bit mask that is 1\n" \
" - ATR_0X - a string of numbers representing a value of the ATR idle state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR idle state register\n" \
" - ATR_RX - a string of numbers representing a value of a ATR receive only state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR receive only state register\n" \
" - ATR_TX - a string of numbers representing a value of the ATR transmit only state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR transmit only state register\n" \
" - ATR_XX - a string of numbers representing a value of the ATR full duplex state register\n" \
"          - \"HIGH\" or \"LOW\" as a value set on each bit on of the ATR full duplex state register\n" \
"\n" \
"Args:\n" \
"    bank (str): the name of a GPIO bank\n" \
"    attr (str): the name of a GPIO attribute\n" \
"    value (str): the new value for this GPIO bank\n" \
"    mask (int, optional): the bit mask to effect which pins are changed\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
static PyObject *Usrp_set_gpio_attr_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 3 || nargs > 5)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 3 to 5.", nargs);

    Expect<std::string> bank;
    if (!(bank = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "bank: %s", bank.what());
    Expect<std::string> attr;
    if (!(attr = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "attr: %s", attr.what());
    Expect<uint32_t> value;
    if (!(value = to<uint32_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "value: %s", value.what());

    Expect<uint32_t> mask;
    Expect<size_t> mboard;

    if (nargs > 3 && !(mask = to<uint32_t>(PyTuple_GetItem(args, 3))))
        return PyErr_Format(PyExc_TypeError, "mask: %s", mask.what());
    if (nargs > 4 && !(mboard = to<size_t>(PyTuple_GetItem(args, 4))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 5) {
            self->dev->set_gpio_attr(bank.get(), attr.get(), value.get(), mask.get(), mboard.get());
        } else if (nargs == 4) {
            self->dev->set_gpio_attr(bank.get(), attr.get(), value.get(), mask.get());
        } else {
            self->dev->set_gpio_attr(bank.get(), attr.get(), value.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *Usrp_set_gpio_attr_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 3 || nargs > 5)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 3 to 5.", nargs);

    Expect<std::string> bank;
    if (!(bank = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "bank: %s", bank.what());
    Expect<std::string> attr;
    if (!(attr = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "attr: %s", attr.what());
    Expect<std::string> value;
    if (!(value = to<std::string>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "value: %s", value.what());

    Expect<uint32_t> mask;
    Expect<size_t> mboard;

    if (nargs > 3 && !(mask = to<uint32_t>(PyTuple_GetItem(args, 3))))
        return PyErr_Format(PyExc_TypeError, "mask: %s", mask.what());
    if (nargs > 4 && !(mboard = to<size_t>(PyTuple_GetItem(args, 4))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 5) {
            self->dev->set_gpio_attr(bank.get(), attr.get(), value.get(), mask.get(), mboard.get());
        } else if (nargs == 4) {
            self->dev->set_gpio_attr(bank.get(), attr.get(), value.get(), mask.get());
        } else {
            self->dev->set_gpio_attr(bank.get(), attr.get(), value.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

PyObject *Usrp_set_gpio_attr(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 3 && nargs <= 5
        && is<std::string>(PyTuple_GetItem(args, 0))
        && is<std::string>(PyTuple_GetItem(args, 1))
        && is<uint32_t>(PyTuple_GetItem(args, 2))
        && (nargs <= 3 || is<uint32_t>(PyTuple_GetItem(args, 3)))
        && (nargs <= 4 || is<size_t>(PyTuple_GetItem(args, 4)))) {
        return Usrp_set_gpio_attr_0(self, args);
    } else if (nargs >= 3 && nargs <= 5
        && is<std::string>(PyTuple_GetItem(args, 0))
        && is<std::string>(PyTuple_GetItem(args, 1))
        && is<std::string>(PyTuple_GetItem(args, 2))
        && (nargs <= 3 || is<uint32_t>(PyTuple_GetItem(args, 3)))
        && (nargs <= 4 || is<size_t>(PyTuple_GetItem(args, 4)))) {
        return Usrp_set_gpio_attr_1(self, args);
    }
    return Usrp_set_gpio_attr_0(self, args);
}

#define DOC_SET_MASTER_CLOCK_RATE \
"Set the master clock rate.\n" \
"What exactly this changes is device-dependent, but it will always\n" \
"affect the rate at which the ADC/DAC is running.\n" \
"Like tuning receive or transmit frequencies, this call will do a best\n" \
"effort to change the master clock rate. The device will coerce to the\n" \
"closest clock rate available, and on many devices won't actually change\n" \
"anything at all. Call get_master_clock_rate() to see which rate was\n" \
"actually applied.\n" \
"Note that changing this value during streaming is not recommended and\n" \
"can have random side effects.\n" \
"If the device has an 'auto clock rate' setting (e.g. B200, see also\n" \
"b200_auto_mcr), calling this function will disable the automatic\n" \
"clock rate selection, and the clock rate will be fixed to rate.\n" \
"\n" \
"Args:\n" \
"    rate (float): the new master clock rate in Hz\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
PyObject *Usrp_set_master_clock_rate(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> rate;
    if (!(rate = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "rate: %s", rate.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_master_clock_rate(rate.get(), mboard.get());
        } else {
            self->dev->set_master_clock_rate(rate.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_NORMALIZED_RX_GAIN \
"Set the normalized RX gain value.\n" \
"The normalized gain is a value in [0, 1], where 0 is the\n" \
"smallest gain value available, and 1 is the largest, independent\n" \
"of the device. In between, gains are linearly interpolated.\n" \
"Check the individual device manual for notes on the gain range.\n" \
"Note that it is not possible to specify a gain name for\n" \
"this function, it will always set the overall gain.\n" \
"\n" \
"Args:\n" \
"    gain (float): the normalized gain value\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_normalized_rx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> gain;
    if (!(gain = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "gain: %s", gain.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_normalized_rx_gain(gain.get(), chan.get());
        } else {
            self->dev->set_normalized_rx_gain(gain.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_NORMALIZED_TX_GAIN \
"Set the normalized TX gain value.\n" \
"See set_normalized_rx_gain() for a discussion on normalized\n" \
"gains.\n" \
"\n" \
"Args:\n" \
"    gain (float): the normalized gain value\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_normalized_tx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> gain;
    if (!(gain = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "gain: %s", gain.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_normalized_tx_gain(gain.get(), chan.get());
        } else {
            self->dev->set_normalized_tx_gain(gain.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_AGC \
"Enable or disable the RX AGC module.\n" \
"Once this module is enabled manual gain settings will be ignored.\n" \
"The AGC will start in a default configuration which should be good for most use cases.\n" \
"Device specific configuration parameters can be found in the property tree.\n" \
"\n" \
"Args:\n" \
"    enable (bool): Enable or Disable the AGC\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_rx_agc(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<bool> enable;
    if (!(enable = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enable: %s", enable.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_agc(enable.get(), chan.get());
        } else {
            self->dev->set_rx_agc(enable.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_ANTENNA \
"Select the RX antenna on the frontend.\n" \
"\n" \
"Args:\n" \
"    ant (str): the antenna name\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_rx_antenna(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> ant;
    if (!(ant = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "ant: %s", ant.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_antenna(ant.get(), chan.get());
        } else {
            self->dev->set_rx_antenna(ant.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_BANDWIDTH \
"Set the RX bandwidth on the frontend.\n" \
"\n" \
"Args:\n" \
"    bandwidth (float): the bandwidth in Hz\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_rx_bandwidth(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> bandwidth;
    if (!(bandwidth = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "bandwidth: %s", bandwidth.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_bandwidth(bandwidth.get(), chan.get());
        } else {
            self->dev->set_rx_bandwidth(bandwidth.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_DC_OFFSET \
"(1) ""Enable/disable the automatic RX DC offset correction.\n" \
"The automatic correction subtracts out the long-run average.\n" \
"When disabled, the averaging option operation is halted.\n" \
"Once halted, the average value will be held constant\n" \
"until the user re-enables the automatic correction\n" \
"or overrides the value by manually setting the offset.\n" \
"\n" \
"Args:\n" \
"    enb (bool): true to enable automatic DC offset correction\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"(2) ""Set a constant RX DC offset value.\n" \
"The value is complex to control both I and Q.\n" \
"Only set this when automatic correction is disabled.\n" \
"\n" \
"Args:\n" \
"    offset (complex): the dc offset (1.0 is full-scale)\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
static PyObject *Usrp_set_rx_dc_offset_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<bool> enb;
    if (!(enb = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enb: %s", enb.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_dc_offset(enb.get(), chan.get());
        } else {
            self->dev->set_rx_dc_offset(enb.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *Usrp_set_rx_dc_offset_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::complex<double>> offset;
    if (!(offset = to<std::complex<double>>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "offset: %s", offset.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_dc_offset(offset.get(), chan.get());
        } else {
            self->dev->set_rx_dc_offset(offset.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

PyObject *Usrp_set_rx_dc_offset(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 1 && nargs <= 2
        && is<bool>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_set_rx_dc_offset_0(self, args);
    } else if (nargs >= 1 && nargs <= 2
        && is<std::complex<double>>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_set_rx_dc_offset_1(self, args);
    }
    return Usrp_set_rx_dc_offset_0(self, args);
}

#define DOC_SET_RX_FREQ \
"Set the RX center frequency.\n" \
"\n" \
"Args:\n" \
"    tune_request (float, dict): tune request instructions\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a tune result object\n"
PyObject *Usrp_set_rx_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<tune_request_t> tune_request;
    if (!(tune_request = to<tune_request_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "tune_request: %s", tune_request.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->set_rx_freq(tune_request.get(), chan.get()));
        } else {
            return from(self->dev->set_rx_freq(tune_request.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_SET_RX_GAIN \
"(1) ""Set the RX gain value for the specified gain element.\n" \
"For an empty name, distribute across all gain elements.\n" \
"\n" \
"Args:\n" \
"    gain (float): the gain in dB\n" \
"    name (str): the name of the gain element\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"(2) ""A convenience wrapper for setting overall RX gain\n" \
"\n" \
"Args:\n" \
"    gain (float): gain\n" \
"    chan (int, optional): chan\n"
static PyObject *Usrp_set_rx_gain_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<double> gain;
    if (!(gain = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "gain: %s", gain.what());
    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_rx_gain(gain.get(), name.get(), chan.get());
        } else {
            self->dev->set_rx_gain(gain.get(), name.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *Usrp_set_rx_gain_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> gain;
    if (!(gain = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "gain: %s", gain.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_gain(gain.get(), chan.get());
        } else {
            self->dev->set_rx_gain(gain.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

PyObject *Usrp_set_rx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 2 && nargs <= 3
        && is<double>(PyTuple_GetItem(args, 0))
        && is<std::string>(PyTuple_GetItem(args, 1))
        && (nargs <= 2 || is<size_t>(PyTuple_GetItem(args, 2)))) {
        return Usrp_set_rx_gain_0(self, args);
    } else if (nargs >= 1 && nargs <= 2
        && is<double>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_set_rx_gain_1(self, args);
    }
    return Usrp_set_rx_gain_0(self, args);
}

#define DOC_SET_RX_GAIN_PROFILE \
"Set the RX gain profile.\n" \
"\n" \
"Args:\n" \
"    profile (str): the profile string option\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_rx_gain_profile(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> profile;
    if (!(profile = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "profile: %s", profile.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_gain_profile(profile.get(), chan.get());
        } else {
            self->dev->set_rx_gain_profile(profile.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_IQ_BALANCE \
"(1) ""Enable/disable the automatic IQ imbalance correction.\n" \
"\n" \
"Args:\n" \
"    enb (bool): true to enable automatic IQ balance correction\n" \
"    chan (int): the channel index 0 to N-1\n" \
"\n" \
"(2) ""Set the RX frontend IQ imbalance correction.\n" \
"Use this to adjust the magnitude and phase of I and Q.\n" \
"\n" \
"Args:\n" \
"    correction (complex): the complex correction (1.0 is full-scale)\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
static PyObject *Usrp_set_rx_iq_balance_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2.", nargs);

    Expect<bool> enb;
    if (!(enb = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enb: %s", enb.what());
    Expect<size_t> chan;
    if (!(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        self->dev->set_rx_iq_balance(enb.get(), chan.get());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *Usrp_set_rx_iq_balance_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::complex<double>> correction;
    if (!(correction = to<std::complex<double>>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "correction: %s", correction.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_iq_balance(correction.get(), chan.get());
        } else {
            self->dev->set_rx_iq_balance(correction.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

PyObject *Usrp_set_rx_iq_balance(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 2 && nargs <= 2
        && is<bool>(PyTuple_GetItem(args, 0))
        && is<size_t>(PyTuple_GetItem(args, 1))) {
        return Usrp_set_rx_iq_balance_0(self, args);
    } else if (nargs >= 1 && nargs <= 2
        && is<std::complex<double>>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_set_rx_iq_balance_1(self, args);
    }
    return Usrp_set_rx_iq_balance_0(self, args);
}

#define DOC_SET_RX_LO_EXPORT_ENABLED \
"Set whether the LO used by the device is exported\n" \
"For USRPs that support exportable LOs, this function\n" \
"configures if the LO used by chan is exported or not.\n" \
"\n" \
"Args:\n" \
"    enabled (bool): if true then export the LO\n" \
"    name (str, optional): the name of the LO stage to update\n" \
"    chan (int, optional): the channel index 0 to N-1 for the source channel\n"
PyObject *Usrp_set_rx_lo_export_enabled(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 3.", nargs);

    Expect<bool> enabled;
    if (!(enabled = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enabled: %s", enabled.what());

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 1 && !(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_rx_lo_export_enabled(enabled.get(), name.get(), chan.get());
        } else if (nargs == 2) {
            self->dev->set_rx_lo_export_enabled(enabled.get(), name.get());
        } else {
            self->dev->set_rx_lo_export_enabled(enabled.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_LO_FREQ \
"Set the RX LO frequency (Advanced).\n" \
"The actual behaviour is device-specific. However, as a rule of thumb,\n" \
"this will coerce the underlying driver into some state. Typical\n" \
"situations include:\n" \
"- LOs are internal, and this function is called to pin an LO to a\n" \
"  certain value. This can force the driver to pick different IFs for\n" \
"  different stages, and there may be situations where this behaviour\n" \
"  can be used to reduce spurs in specific bands.\n" \
"- LOs are external. In this case, this function is used to notify UHD\n" \
"  what the actual value of an externally provided LO is. The only time\n" \
"  when calling this function is necessary is when the LO source is set\n" \
"  to external, but the external LO can't be tuned to the exact value\n" \
"  required by UHD to achieve a certain center frequency. In this case,\n" \
"  calling set_rx_lo_freq() will let UHD know that the LO is not the\n" \
"  expected value, and it's possible that UHD will find other ways to\n" \
"  compensate for the LO offset.\n" \
"\n" \
"Args:\n" \
"    freq (float): the frequency to set the LO to\n" \
"    name (str): the name of the LO stage to update\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: a coerced LO frequency\n"
PyObject *Usrp_set_rx_lo_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<double> freq;
    if (!(freq = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "freq: %s", freq.what());
    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            return from(self->dev->set_rx_lo_freq(freq.get(), name.get(), chan.get()));
        } else {
            return from(self->dev->set_rx_lo_freq(freq.get(), name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_SET_RX_LO_SOURCE \
"Set the LO source for the USRP device.\n" \
"For USRPs that support selectable LO sources, this function allows\n" \
"switching between them. Typical options for source: internal, external.\n" \
"\n" \
"Args:\n" \
"    src (str): a string representing the LO source\n" \
"    name (str, optional): the name of the LO stage to update. If the wildcard value\n" \
"                          ALL_LOS is used, the setting will be applied to all LOs on\n" \
"                          this channel.\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_rx_lo_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 3.", nargs);

    Expect<std::string> src;
    if (!(src = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "src: %s", src.what());

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 1 && !(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_rx_lo_source(src.get(), name.get(), chan.get());
        } else if (nargs == 2) {
            self->dev->set_rx_lo_source(src.get(), name.get());
        } else {
            self->dev->set_rx_lo_source(src.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_RATE \
"Set the RX sample rate.\n" \
"\n" \
"Args:\n" \
"    rate (float): the rate in Sps\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_rx_rate(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> rate;
    if (!(rate = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "rate: %s", rate.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_rate(rate.get(), chan.get());
        } else {
            self->dev->set_rx_rate(rate.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_RX_SUBDEV_SPEC \
"Set the RX frontend specification:\n" \
"The subdev spec maps a physical part of a daughter-board to a channel number.\n" \
"Set the subdev spec before calling into any methods with a channel number.\n" \
"The subdev spec must be the same size across all motherboards.\n" \
"\n" \
"Args:\n" \
"    spec (str): the new frontend specification\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
PyObject *Usrp_set_rx_subdev_spec(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<usrp::subdev_spec_t> spec;
    if (!(spec = to<usrp::subdev_spec_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "spec: %s", spec.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_rx_subdev_spec(spec.get(), mboard.get());
        } else {
            self->dev->set_rx_subdev_spec(spec.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TIME_NEXT_PPS \
"Set the time registers on the usrp at the next pps tick.\n" \
"The values will not be latched in until the pulse occurs.\n" \
"It is recommended that the user sleep(1) after calling to ensure\n" \
"that the time registers will be in a known state prior to use.\n" \
"Note: Because this call sets the time on the \"next\" pps,\n" \
"the seconds in the time spec should be current seconds + 1.\n" \
"\n" \
"Args:\n" \
"    time_spec (float, TimeSpec): the time to latch into the usrp device\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
PyObject *Usrp_set_time_next_pps(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<time_spec_t> time_spec;
    if (!(time_spec = to<time_spec_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "time_spec: %s", time_spec.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_time_next_pps(time_spec.get(), mboard.get());
        } else {
            self->dev->set_time_next_pps(time_spec.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TIME_NOW \
"Sets the time registers on the usrp immediately.\n" \
"If only one MIMO master is present in your configuration, set_time_now is\n" \
"safe to use because the slave's time automatically follows the master's time.\n" \
"Otherwise, this call cannot set the time synchronously across multiple devices.\n" \
"Please use the set_time_next_pps or set_time_unknown_pps calls with a PPS signal.\n" \
"\n" \
"Args:\n" \
"    time_spec (float, TimeSpec): the time to latch into the usrp device\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
PyObject *Usrp_set_time_now(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<time_spec_t> time_spec;
    if (!(time_spec = to<time_spec_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "time_spec: %s", time_spec.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_time_now(time_spec.get(), mboard.get());
        } else {
            self->dev->set_time_now(time_spec.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TIME_SOURCE \
"Set the time source for the usrp device.\n" \
"This sets the method of time synchronization,\n" \
"typically a pulse per second or an encoded time.\n" \
"Typical options for source: external, MIMO.\n" \
"\n" \
"Args:\n" \
"    source (str): a string representing the time source\n" \
"    mboard (int, optional): which motherboard to set the config\n"
PyObject *Usrp_set_time_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> source;
    if (!(source = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "source: %s", source.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_time_source(source.get(), mboard.get());
        } else {
            self->dev->set_time_source(source.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TIME_SOURCE_OUT \
"Send the time source to an output connector.\n" \
"This call is only applicable on devices with PPS outputs.\n" \
"By default, the PPS output will be enabled for ease of use.\n" \
"This call may be used to enable or disable the output.\n" \
"\n" \
"Args:\n" \
"    enb (bool): true to output the time source.\n" \
"    mboard (int, optional): which motherboard to set\n"
PyObject *Usrp_set_time_source_out(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<bool> enb;
    if (!(enb = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enb: %s", enb.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_time_source_out(enb.get(), mboard.get());
        } else {
            self->dev->set_time_source_out(enb.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TIME_UNKNOWN_PPS \
"Synchronize the times across all motherboards in this configuration.\n" \
"Use this method to sync the times when the edge of the PPS is unknown.\n" \
"Ex: Host machine is not attached to serial port of GPSDO\n" \
"and can therefore not query the GPSDO for the PPS edge.\n" \
"This is a 2-step process, and will take at most 2 seconds to complete.\n" \
"Upon completion, the times will be synchronized to the time provided.\n" \
"- Step1: wait for the last pps time to transition to catch the edge\n" \
"- Step2: set the time at the next pps (synchronous for all boards)\n" \
"\n" \
"Args:\n" \
"    time_spec (float, TimeSpec): the time to latch at the next pps after catching the edge\n"
PyObject *Usrp_set_time_unknown_pps(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 1)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1.", nargs);

    Expect<time_spec_t> time_spec;
    if (!(time_spec = to<time_spec_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "time_spec: %s", time_spec.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        self->dev->set_time_unknown_pps(time_spec.get());
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_ANTENNA \
"Select the TX antenna on the frontend.\n" \
"\n" \
"Args:\n" \
"    ant (str): the antenna name\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_antenna(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> ant;
    if (!(ant = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "ant: %s", ant.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_antenna(ant.get(), chan.get());
        } else {
            self->dev->set_tx_antenna(ant.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_BANDWIDTH \
"Set the TX bandwidth on the frontend.\n" \
"\n" \
"Args:\n" \
"    bandwidth (float): the bandwidth in Hz\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_bandwidth(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> bandwidth;
    if (!(bandwidth = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "bandwidth: %s", bandwidth.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_bandwidth(bandwidth.get(), chan.get());
        } else {
            self->dev->set_tx_bandwidth(bandwidth.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_DC_OFFSET \
"Set a constant TX DC offset value.\n" \
"The value is complex to control both I and Q.\n" \
"\n" \
"Args:\n" \
"    offset (complex): the dc offset (1.0 is full-scale)\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_dc_offset(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::complex<double>> offset;
    if (!(offset = to<std::complex<double>>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "offset: %s", offset.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_dc_offset(offset.get(), chan.get());
        } else {
            self->dev->set_tx_dc_offset(offset.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_FREQ \
"Set the TX center frequency.\n" \
"\n" \
"Args:\n" \
"    tune_request (float, dict): tune request instructions\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    dict: a tune result object\n"
PyObject *Usrp_set_tx_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<tune_request_t> tune_request;
    if (!(tune_request = to<tune_request_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "tune_request: %s", tune_request.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            return from(self->dev->set_tx_freq(tune_request.get(), chan.get()));
        } else {
            return from(self->dev->set_tx_freq(tune_request.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_SET_TX_GAIN \
"(1) ""Set the TX gain value for the specified gain element.\n" \
"For an empty name, distribute across all gain elements.\n" \
"\n" \
"Args:\n" \
"    gain (float): the gain in dB\n" \
"    name (str): the name of the gain element\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"(2) ""A convenience wrapper for setting overall TX gain\n" \
"\n" \
"Args:\n" \
"    gain (float): gain\n" \
"    chan (int, optional): chan\n"
static PyObject *Usrp_set_tx_gain_0(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<double> gain;
    if (!(gain = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "gain: %s", gain.what());
    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_tx_gain(gain.get(), name.get(), chan.get());
        } else {
            self->dev->set_tx_gain(gain.get(), name.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *Usrp_set_tx_gain_1(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> gain;
    if (!(gain = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "gain: %s", gain.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_gain(gain.get(), chan.get());
        } else {
            self->dev->set_tx_gain(gain.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

PyObject *Usrp_set_tx_gain(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs >= 2 && nargs <= 3
        && is<double>(PyTuple_GetItem(args, 0))
        && is<std::string>(PyTuple_GetItem(args, 1))
        && (nargs <= 2 || is<size_t>(PyTuple_GetItem(args, 2)))) {
        return Usrp_set_tx_gain_0(self, args);
    } else if (nargs >= 1 && nargs <= 2
        && is<double>(PyTuple_GetItem(args, 0))
        && (nargs <= 1 || is<size_t>(PyTuple_GetItem(args, 1)))) {
        return Usrp_set_tx_gain_1(self, args);
    }
    return Usrp_set_tx_gain_0(self, args);
}

#define DOC_SET_TX_GAIN_PROFILE \
"Set the TX gain profile.\n" \
"\n" \
"Args:\n" \
"    profile (str): the profile string option\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_gain_profile(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::string> profile;
    if (!(profile = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "profile: %s", profile.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_gain_profile(profile.get(), chan.get());
        } else {
            self->dev->set_tx_gain_profile(profile.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_IQ_BALANCE \
"Set the TX frontend IQ imbalance correction.\n" \
"Use this to adjust the magnitude and phase of I and Q.\n" \
"\n" \
"Args:\n" \
"    correction (complex): the complex correction (1.0 is full-scale)\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_iq_balance(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<std::complex<double>> correction;
    if (!(correction = to<std::complex<double>>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "correction: %s", correction.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_iq_balance(correction.get(), chan.get());
        } else {
            self->dev->set_tx_iq_balance(correction.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_LO_EXPORT_ENABLED \
"Set whether the TX LO used by the device is exported\n" \
"For USRPs that support exportable LOs, this function\n" \
"configures if the LO used by chan is exported or not.\n" \
"\n" \
"Args:\n" \
"    enabled (bool): if true then export the LO\n" \
"    name (str, optional): the name of the LO stage to update\n" \
"    chan (int, optional): the channel index 0 to N-1 for the source channel\n"
PyObject *Usrp_set_tx_lo_export_enabled(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 3.", nargs);

    Expect<bool> enabled;
    if (!(enabled = to<bool>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "enabled: %s", enabled.what());

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 1 && !(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_tx_lo_export_enabled(enabled.get(), name.get(), chan.get());
        } else if (nargs == 2) {
            self->dev->set_tx_lo_export_enabled(enabled.get(), name.get());
        } else {
            self->dev->set_tx_lo_export_enabled(enabled.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_LO_FREQ \
"Set the TX LO frequency (Advanced).\n" \
"The actual behaviour is device-specific. However, as a rule of thumb,\n" \
"this will coerce the underlying driver into some state. Typical\n" \
"situations include:\n" \
"- LOs are internal, and this function is called to pin an LO to a\n" \
"  certain value. This can force the driver to pick different IFs for\n" \
"  different stages, and there may be situations where this behaviour\n" \
"  can be used to reduce spurs in specific bands.\n" \
"- LOs are external. In this case, this function is used to notify UHD\n" \
"  what the actual value of an externally provided LO is. The only time\n" \
"  when calling this function is necessary is when the LO source is set\n" \
"  to external, but the external LO can't be tuned to the exact value\n" \
"  required by UHD to achieve a certain center frequency. In this case,\n" \
"  calling set_tx_lo_freq() will let UHD know that the LO is not the\n" \
"  expected value, and it's possible that UHD will find other ways to\n" \
"  compensate for the LO offset.\n" \
"\n" \
"Args:\n" \
"    freq (float): the frequency to set the LO to\n" \
"    name (str): the name of the LO stage to update\n" \
"    chan (int, optional): the channel index 0 to N-1\n" \
"\n" \
"Returns:\n" \
"    float: a coerced LO frequency\n"
PyObject *Usrp_set_tx_lo_freq(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<double> freq;
    if (!(freq = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "freq: %s", freq.what());
    Expect<std::string> name;
    if (!(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());

    Expect<size_t> chan;
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            return from(self->dev->set_tx_lo_freq(freq.get(), name.get(), chan.get()));
        } else {
            return from(self->dev->set_tx_lo_freq(freq.get(), name.get()));
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }
}

#define DOC_SET_TX_LO_SOURCE \
"Set the TX LO source for the USRP device.\n" \
"For USRPs that support selectable LO sources, this function allows\n" \
"switching between them. Typical options for source: internal, external.\n" \
"\n" \
"Args:\n" \
"    src (str): a string representing the LO source\n" \
"    name (str, optional): the name of the LO stage to update. If the wildcard value\n" \
"                          ALL_LOS is used, the setting will be applied to all LOs on\n" \
"                          this channel.\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_lo_source(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 3.", nargs);

    Expect<std::string> src;
    if (!(src = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "src: %s", src.what());

    Expect<std::string> name;
    Expect<size_t> chan;

    if (nargs > 1 && !(name = to<std::string>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "name: %s", name.what());
    if (nargs > 2 && !(chan = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_tx_lo_source(src.get(), name.get(), chan.get());
        } else if (nargs == 2) {
            self->dev->set_tx_lo_source(src.get(), name.get());
        } else {
            self->dev->set_tx_lo_source(src.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_RATE \
"Set the TX sample rate.\n" \
"\n" \
"Args:\n" \
"    rate (float): the rate in Sps\n" \
"    chan (int, optional): the channel index 0 to N-1\n"
PyObject *Usrp_set_tx_rate(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<double> rate;
    if (!(rate = to<double>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "rate: %s", rate.what());

    Expect<size_t> chan;
    if (nargs > 1 && !(chan = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "chan: %s", chan.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_rate(rate.get(), chan.get());
        } else {
            self->dev->set_tx_rate(rate.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_TX_SUBDEV_SPEC \
"Set the TX frontend specification:\n" \
"The subdev spec maps a physical part of a daughter-board to a channel number.\n" \
"Set the subdev spec before calling into any methods with a channel number.\n" \
"The subdev spec must be the same size across all motherboards.\n" \
"\n" \
"Args:\n" \
"    spec (str): the new frontend specification\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
PyObject *Usrp_set_tx_subdev_spec(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 1 || nargs > 2)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 1 to 2.", nargs);

    Expect<usrp::subdev_spec_t> spec;
    if (!(spec = to<usrp::subdev_spec_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "spec: %s", spec.what());

    Expect<size_t> mboard;
    if (nargs > 1 && !(mboard = to<size_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 2) {
            self->dev->set_tx_subdev_spec(spec.get(), mboard.get());
        } else {
            self->dev->set_tx_subdev_spec(spec.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_SET_USER_REGISTER \
"Perform write on the user configuration register bus. These only exist if\n" \
"the user has implemented custom setting registers in the device FPGA.\n" \
"\n" \
"Args:\n" \
"    addr (int): 8-bit register address\n" \
"    data (int): 32-bit register value\n" \
"    mboard (int, optional): which motherboard to set the user register\n"
PyObject *Usrp_set_user_register(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 2 || nargs > 3)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 2 to 3.", nargs);

    Expect<uint8_t> addr;
    if (!(addr = to<uint8_t>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "addr: %s", addr.what());
    Expect<uint32_t> data;
    if (!(data = to<uint32_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "data: %s", data.what());

    Expect<size_t> mboard;
    if (nargs > 2 && !(mboard = to<size_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 3) {
            self->dev->set_user_register(addr.get(), data.get(), mboard.get());
        } else {
            self->dev->set_user_register(addr.get(), data.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

#define DOC_WRITE_REGISTER \
"Write a low-level register field for a register in the USRP hardware\n" \
"\n" \
"Args:\n" \
"    path (str): the full path to the register\n" \
"    field (int): the identifier of bitfield to be written (all other bits remain unchanged)\n" \
"    value (int): the value to write to the register field\n" \
"    mboard (int, optional): the motherboard index 0 to M-1\n"
PyObject *Usrp_write_register(Usrp *self, PyObject *args) {

    const Py_ssize_t nargs = PyTuple_Size(args);
    if (nargs < 3 || nargs > 4)
        return PyErr_Format(PyExc_TypeError, "Invalid number of arguments: got %ld, expected 3 to 4.", nargs);

    Expect<std::string> path;
    if (!(path = to<std::string>(PyTuple_GetItem(args, 0))))
        return PyErr_Format(PyExc_TypeError, "path: %s", path.what());
    Expect<uint32_t> field;
    if (!(field = to<uint32_t>(PyTuple_GetItem(args, 1))))
        return PyErr_Format(PyExc_TypeError, "field: %s", field.what());
    Expect<uint64_t> value;
    if (!(value = to<uint64_t>(PyTuple_GetItem(args, 2))))
        return PyErr_Format(PyExc_TypeError, "value: %s", value.what());

    Expect<size_t> mboard;
    if (nargs > 3 && !(mboard = to<size_t>(PyTuple_GetItem(args, 3))))
        return PyErr_Format(PyExc_TypeError, "mboard: %s", mboard.what());

    try {
        std::lock_guard<std::mutex> lg(self->dev_lock);
        if (nargs == 4) {
            self->dev->write_register(path.get(), field.get(), value.get(), mboard.get());
        } else {
            self->dev->write_register(path.get(), field.get(), value.get());
        }
    } catch (const uhd::exception &e) {
        return PyErr_Format(UhdError, "%s", e.what());
    }

    Py_INCREF(Py_None);
    return Py_None;
}

const std::vector<PyMethodDef> Usrp_gen_methods {
    {"clear_command_time", (PyCFunction)Usrp_clear_command_time, METH_VARARGS, DOC_CLEAR_COMMAND_TIME},
    {"enumerate_registers", (PyCFunction)Usrp_enumerate_registers, METH_VARARGS, DOC_ENUMERATE_REGISTERS},
    {"get_clock_source", (PyCFunction)Usrp_get_clock_source, METH_VARARGS, DOC_GET_CLOCK_SOURCE},
    {"get_clock_sources", (PyCFunction)Usrp_get_clock_sources, METH_VARARGS, DOC_GET_CLOCK_SOURCES},
    {"get_fe_rx_freq_range", (PyCFunction)Usrp_get_fe_rx_freq_range, METH_VARARGS, DOC_GET_FE_RX_FREQ_RANGE},
    {"get_fe_tx_freq_range", (PyCFunction)Usrp_get_fe_tx_freq_range, METH_VARARGS, DOC_GET_FE_TX_FREQ_RANGE},
    {"get_filter_names", (PyCFunction)Usrp_get_filter_names, METH_VARARGS, DOC_GET_FILTER_NAMES},
    {"get_gpio_attr", (PyCFunction)Usrp_get_gpio_attr, METH_VARARGS, DOC_GET_GPIO_ATTR},
    {"get_gpio_banks", (PyCFunction)Usrp_get_gpio_banks, METH_VARARGS, DOC_GET_GPIO_BANKS},
    {"get_gpio_string_attr", (PyCFunction)Usrp_get_gpio_string_attr, METH_VARARGS, DOC_GET_GPIO_STRING_ATTR},
    {"get_master_clock_rate", (PyCFunction)Usrp_get_master_clock_rate, METH_VARARGS, DOC_GET_MASTER_CLOCK_RATE},
    {"get_mboard_name", (PyCFunction)Usrp_get_mboard_name, METH_VARARGS, DOC_GET_MBOARD_NAME},
    {"get_mboard_sensor", (PyCFunction)Usrp_get_mboard_sensor, METH_VARARGS, DOC_GET_MBOARD_SENSOR},
    {"get_mboard_sensor_names", (PyCFunction)Usrp_get_mboard_sensor_names, METH_VARARGS, DOC_GET_MBOARD_SENSOR_NAMES},
    {"get_normalized_rx_gain", (PyCFunction)Usrp_get_normalized_rx_gain, METH_VARARGS, DOC_GET_NORMALIZED_RX_GAIN},
    {"get_normalized_tx_gain", (PyCFunction)Usrp_get_normalized_tx_gain, METH_VARARGS, DOC_GET_NORMALIZED_TX_GAIN},
    {"get_num_mboards", (PyCFunction)Usrp_get_num_mboards, METH_VARARGS, DOC_GET_NUM_MBOARDS},
    {"get_pp_string", (PyCFunction)Usrp_get_pp_string, METH_VARARGS, DOC_GET_PP_STRING},
    {"get_rx_antenna", (PyCFunction)Usrp_get_rx_antenna, METH_VARARGS, DOC_GET_RX_ANTENNA},
    {"get_rx_antennas", (PyCFunction)Usrp_get_rx_antennas, METH_VARARGS, DOC_GET_RX_ANTENNAS},
    {"get_rx_bandwidth", (PyCFunction)Usrp_get_rx_bandwidth, METH_VARARGS, DOC_GET_RX_BANDWIDTH},
    {"get_rx_bandwidth_range", (PyCFunction)Usrp_get_rx_bandwidth_range, METH_VARARGS, DOC_GET_RX_BANDWIDTH_RANGE},
    {"get_rx_freq", (PyCFunction)Usrp_get_rx_freq, METH_VARARGS, DOC_GET_RX_FREQ},
    {"get_rx_freq_range", (PyCFunction)Usrp_get_rx_freq_range, METH_VARARGS, DOC_GET_RX_FREQ_RANGE},
    {"get_rx_gain", (PyCFunction)Usrp_get_rx_gain, METH_VARARGS, DOC_GET_RX_GAIN},
    {"get_rx_gain_names", (PyCFunction)Usrp_get_rx_gain_names, METH_VARARGS, DOC_GET_RX_GAIN_NAMES},
    {"get_rx_gain_profile", (PyCFunction)Usrp_get_rx_gain_profile, METH_VARARGS, DOC_GET_RX_GAIN_PROFILE},
    {"get_rx_gain_profile_names", (PyCFunction)Usrp_get_rx_gain_profile_names, METH_VARARGS, DOC_GET_RX_GAIN_PROFILE_NAMES},
    {"get_rx_gain_range", (PyCFunction)Usrp_get_rx_gain_range, METH_VARARGS, DOC_GET_RX_GAIN_RANGE},
    {"get_rx_lo_export_enabled", (PyCFunction)Usrp_get_rx_lo_export_enabled, METH_VARARGS, DOC_GET_RX_LO_EXPORT_ENABLED},
    {"get_rx_lo_freq", (PyCFunction)Usrp_get_rx_lo_freq, METH_VARARGS, DOC_GET_RX_LO_FREQ},
    {"get_rx_lo_freq_range", (PyCFunction)Usrp_get_rx_lo_freq_range, METH_VARARGS, DOC_GET_RX_LO_FREQ_RANGE},
    {"get_rx_lo_names", (PyCFunction)Usrp_get_rx_lo_names, METH_VARARGS, DOC_GET_RX_LO_NAMES},
    {"get_rx_lo_source", (PyCFunction)Usrp_get_rx_lo_source, METH_VARARGS, DOC_GET_RX_LO_SOURCE},
    {"get_rx_lo_sources", (PyCFunction)Usrp_get_rx_lo_sources, METH_VARARGS, DOC_GET_RX_LO_SOURCES},
    {"get_rx_num_channels", (PyCFunction)Usrp_get_rx_num_channels, METH_VARARGS, DOC_GET_RX_NUM_CHANNELS},
    {"get_rx_rate", (PyCFunction)Usrp_get_rx_rate, METH_VARARGS, DOC_GET_RX_RATE},
    {"get_rx_rates", (PyCFunction)Usrp_get_rx_rates, METH_VARARGS, DOC_GET_RX_RATES},
    {"get_rx_sensor", (PyCFunction)Usrp_get_rx_sensor, METH_VARARGS, DOC_GET_RX_SENSOR},
    {"get_rx_sensor_names", (PyCFunction)Usrp_get_rx_sensor_names, METH_VARARGS, DOC_GET_RX_SENSOR_NAMES},
    {"get_rx_subdev_name", (PyCFunction)Usrp_get_rx_subdev_name, METH_VARARGS, DOC_GET_RX_SUBDEV_NAME},
    {"get_rx_subdev_spec", (PyCFunction)Usrp_get_rx_subdev_spec, METH_VARARGS, DOC_GET_RX_SUBDEV_SPEC},
    {"get_time_last_pps", (PyCFunction)Usrp_get_time_last_pps, METH_VARARGS, DOC_GET_TIME_LAST_PPS},
    {"get_time_now", (PyCFunction)Usrp_get_time_now, METH_VARARGS, DOC_GET_TIME_NOW},
    {"get_time_source", (PyCFunction)Usrp_get_time_source, METH_VARARGS, DOC_GET_TIME_SOURCE},
    {"get_time_sources", (PyCFunction)Usrp_get_time_sources, METH_VARARGS, DOC_GET_TIME_SOURCES},
    {"get_time_synchronized", (PyCFunction)Usrp_get_time_synchronized, METH_VARARGS, DOC_GET_TIME_SYNCHRONIZED},
    {"get_tx_antenna", (PyCFunction)Usrp_get_tx_antenna, METH_VARARGS, DOC_GET_TX_ANTENNA},
    {"get_tx_antennas", (PyCFunction)Usrp_get_tx_antennas, METH_VARARGS, DOC_GET_TX_ANTENNAS},
    {"get_tx_bandwidth", (PyCFunction)Usrp_get_tx_bandwidth, METH_VARARGS, DOC_GET_TX_BANDWIDTH},
    {"get_tx_bandwidth_range", (PyCFunction)Usrp_get_tx_bandwidth_range, METH_VARARGS, DOC_GET_TX_BANDWIDTH_RANGE},
    {"get_tx_freq", (PyCFunction)Usrp_get_tx_freq, METH_VARARGS, DOC_GET_TX_FREQ},
    {"get_tx_freq_range", (PyCFunction)Usrp_get_tx_freq_range, METH_VARARGS, DOC_GET_TX_FREQ_RANGE},
    {"get_tx_gain", (PyCFunction)Usrp_get_tx_gain, METH_VARARGS, DOC_GET_TX_GAIN},
    {"get_tx_gain_names", (PyCFunction)Usrp_get_tx_gain_names, METH_VARARGS, DOC_GET_TX_GAIN_NAMES},
    {"get_tx_gain_profile", (PyCFunction)Usrp_get_tx_gain_profile, METH_VARARGS, DOC_GET_TX_GAIN_PROFILE},
    {"get_tx_gain_profile_names", (PyCFunction)Usrp_get_tx_gain_profile_names, METH_VARARGS, DOC_GET_TX_GAIN_PROFILE_NAMES},
    {"get_tx_gain_range", (PyCFunction)Usrp_get_tx_gain_range, METH_VARARGS, DOC_GET_TX_GAIN_RANGE},
    {"get_tx_lo_export_enabled", (PyCFunction)Usrp_get_tx_lo_export_enabled, METH_VARARGS, DOC_GET_TX_LO_EXPORT_ENABLED},
    {"get_tx_lo_freq", (PyCFunction)Usrp_get_tx_lo_freq, METH_VARARGS, DOC_GET_TX_LO_FREQ},
    {"get_tx_lo_freq_range", (PyCFunction)Usrp_get_tx_lo_freq_range, METH_VARARGS, DOC_GET_TX_LO_FREQ_RANGE},
    {"get_tx_lo_names", (PyCFunction)Usrp_get_tx_lo_names, METH_VARARGS, DOC_GET_TX_LO_NAMES},
    {"get_tx_lo_source", (PyCFunction)Usrp_get_tx_lo_source, METH_VARARGS, DOC_GET_TX_LO_SOURCE},
    {"get_tx_lo_sources", (PyCFunction)Usrp_get_tx_lo_sources, METH_VARARGS, DOC_GET_TX_LO_SOURCES},
    {"get_tx_num_channels", (PyCFunction)Usrp_get_tx_num_channels, METH_VARARGS, DOC_GET_TX_NUM_CHANNELS},
    {"get_tx_rate", (PyCFunction)Usrp_get_tx_rate, METH_VARARGS, DOC_GET_TX_RATE},
    {"get_tx_rates", (PyCFunction)Usrp_get_tx_rates, METH_VARARGS, DOC_GET_TX_RATES},
    {"get_tx_sensor", (PyCFunction)Usrp_get_tx_sensor, METH_VARARGS, DOC_GET_TX_SENSOR},
    {"get_tx_sensor_names", (PyCFunction)Usrp_get_tx_sensor_names, METH_VARARGS, DOC_GET_TX_SENSOR_NAMES},
    {"get_tx_subdev_name", (PyCFunction)Usrp_get_tx_subdev_name, METH_VARARGS, DOC_GET_TX_SUBDEV_NAME},
    {"get_tx_subdev_spec", (PyCFunction)Usrp_get_tx_subdev_spec, METH_VARARGS, DOC_GET_TX_SUBDEV_SPEC},
    {"get_usrp_rx_info", (PyCFunction)Usrp_get_usrp_rx_info, METH_VARARGS, DOC_GET_USRP_RX_INFO},
    {"get_usrp_tx_info", (PyCFunction)Usrp_get_usrp_tx_info, METH_VARARGS, DOC_GET_USRP_TX_INFO},
    {"read_register", (PyCFunction)Usrp_read_register, METH_VARARGS, DOC_READ_REGISTER},
    {"set_clock_source", (PyCFunction)Usrp_set_clock_source, METH_VARARGS, DOC_SET_CLOCK_SOURCE},
    {"set_clock_source_out", (PyCFunction)Usrp_set_clock_source_out, METH_VARARGS, DOC_SET_CLOCK_SOURCE_OUT},
    {"set_command_time", (PyCFunction)Usrp_set_command_time, METH_VARARGS, DOC_SET_COMMAND_TIME},
    {"set_gpio_attr", (PyCFunction)Usrp_set_gpio_attr, METH_VARARGS, DOC_SET_GPIO_ATTR},
    {"set_master_clock_rate", (PyCFunction)Usrp_set_master_clock_rate, METH_VARARGS, DOC_SET_MASTER_CLOCK_RATE},
    {"set_normalized_rx_gain", (PyCFunction)Usrp_set_normalized_rx_gain, METH_VARARGS, DOC_SET_NORMALIZED_RX_GAIN},
    {"set_normalized_tx_gain", (PyCFunction)Usrp_set_normalized_tx_gain, METH_VARARGS, DOC_SET_NORMALIZED_TX_GAIN},
    {"set_rx_agc", (PyCFunction)Usrp_set_rx_agc, METH_VARARGS, DOC_SET_RX_AGC},
    {"set_rx_antenna", (PyCFunction)Usrp_set_rx_antenna, METH_VARARGS, DOC_SET_RX_ANTENNA},
    {"set_rx_bandwidth", (PyCFunction)Usrp_set_rx_bandwidth, METH_VARARGS, DOC_SET_RX_BANDWIDTH},
    {"set_rx_dc_offset", (PyCFunction)Usrp_set_rx_dc_offset, METH_VARARGS, DOC_SET_RX_DC_OFFSET},
    {"set_rx_freq", (PyCFunction)Usrp_set_rx_freq, METH_VARARGS, DOC_SET_RX_FREQ},
    {"set_rx_gain", (PyCFunction)Usrp_set_rx_gain, METH_VARARGS, DOC_SET_RX_GAIN},
    {"set_rx_gain_profile", (PyCFunction)Usrp_set_rx_gain_profile, METH_VARARGS, DOC_SET_RX_GAIN_PROFILE},
    {"set_rx_iq_balance", (PyCFunction)Usrp_set_rx_iq_balance, METH_VARARGS, DOC_SET_RX_IQ_BALANCE},
    {"set_rx_lo_export_enabled", (PyCFunction)Usrp_set_rx_lo_export_enabled, METH_VARARGS, DOC_SET_RX_LO_EXPORT_ENABLED},
    {"set_rx_lo_freq", (PyCFunction)Usrp_set_rx_lo_freq, METH_VARARGS, DOC_SET_RX_LO_FREQ},
    {"set_rx_lo_source", (PyCFunction)Usrp_set_rx_lo_source, METH_VARARGS, DOC_SET_RX_LO_SOURCE},
    {"set_rx_rate", (PyCFunction)Usrp_set_rx_rate, METH_VARARGS, DOC_SET_RX_RATE},
    {"set_rx_subdev_spec", (PyCFunction)Usrp_set_rx_subdev_spec, METH_VARARGS, DOC_SET_RX_SUBDEV_SPEC},
    {"set_time_next_pps", (PyCFunction)Usrp_set_time_next_pps, METH_VARARGS, DOC_SET_TIME_NEXT_PPS},
    {"set_time_now", (PyCFunction)Usrp_set_time_now, METH_VARARGS, DOC_SET_TIME_NOW},
    {"set_time_source", (PyCFunction)Usrp_set_time_source, METH_VARARGS, DOC_SET_TIME_SOURCE},
    {"set_time_source_out", (PyCFunction)Usrp_set_time_source_out, METH_VARARGS, DOC_SET_TIME_SOURCE_OUT},
    {"set_time_unknown_pps", (PyCFunction)Usrp_set_time_unknown_pps, METH_VARARGS, DOC_SET_TIME_UNKNOWN_PPS},
    {"set_tx_antenna", (PyCFunction)Usrp_set_tx_antenna, METH_VARARGS, DOC_SET_TX_ANTENNA},
    {"set_tx_bandwidth", (PyCFunction)Usrp_set_tx_bandwidth, METH_VARARGS, DOC_SET_TX_BANDWIDTH},
    {"set_tx_dc_offset", (PyCFunction)Usrp_set_tx_dc_offset, METH_VARARGS, DOC_SET_TX_DC_OFFSET},
    {"set_tx_freq", (PyCFunction)Usrp_set_tx_freq, METH_VARARGS, DOC_SET_TX_FREQ},
    {"set_tx_gain", (PyCFunction)Usrp_set_tx_gain, METH_VARARGS, DOC_SET_TX_GAIN},
    {"set_tx_gain_profile", (PyCFunction)Usrp_set_tx_gain_profile, METH_VARARGS, DOC_SET_TX_GAIN_PROFILE},
    {"set_tx_iq_balance", (PyCFunction)Usrp_set_tx_iq_balance, METH_VARARGS, DOC_SET_TX_IQ_BALANCE},
    {"set_tx_lo_export_enabled", (PyCFunction)Usrp_set_tx_lo_export_enabled, METH_VARARGS, DOC_SET_TX_LO_EXPORT_ENABLED},
    {"set_tx_lo_freq", (PyCFunction)Usrp_set_tx_lo_freq, METH_VARARGS, DOC_SET_TX_LO_FREQ},
    {"set_tx_lo_source", (PyCFunction)Usrp_set_tx_lo_source, METH_VARARGS, DOC_SET_TX_LO_SOURCE},
    {"set_tx_rate", (PyCFunction)Usrp_set_tx_rate, METH_VARARGS, DOC_SET_TX_RATE},
    {"set_tx_subdev_spec", (PyCFunction)Usrp_set_tx_subdev_spec, METH_VARARGS, DOC_SET_TX_SUBDEV_SPEC},
    {"set_user_register", (PyCFunction)Usrp_set_user_register, METH_VARARGS, DOC_SET_USER_REGISTER},
    {"write_register", (PyCFunction)Usrp_write_register, METH_VARARGS, DOC_WRITE_REGISTER},
};

}

#endif /** __UHD_GEN_HPP__ **/

#endif /** UHD_VERSION **/
